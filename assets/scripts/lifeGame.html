<!DOCTYPE html>
<html>
<head>
<title>
Game Of Life
</title>

<head>
	<style type="text/css">
		.button {
		  border: none;
		  padding: 0.5% 0.5%;
		  text-align: center;
		  text-decoration: none;
		  display: inline-block;
		  border-radius: 8px;
		  font-size: 90%;
		}
	</style>
</head>

<body style="background-color:#000000;">

<h1 style="color:white; text-align: center;">Juego de la Vida</h1>
<br>
<p style="text-align: center; color: white">Para empezar a jugar, hacé click adentro del visor para darle vida a alguna célula. Desués, hacé click en Comenzar/Detener para ver la evolución.</p>
<br>

<div style="text-align: center;">
	<button type="button" class="button" onclick="window.history.back();">Volver al Menu</button>
	<br>
	<br>
	<canvas id="Mundo" width="700" height="700"
	style="background-color:black; border:1px solid; border-color:white; text-align: center;">
	</canvas>
	<br>

	<button class="button" onclick="iniciar()">Limpiar pantalla</button>
	<button class="button" onclick="nextTurn()">Paso de ejecución</button>
	<button class="button" onclick="active()">Comenzar/Detener evolución</button>
	<button class="button" onclick="printNivel()">Guardar posición</button>
	<button class="button" onclick="setNivel()">Ultima posición guardada</button>

</div>

<script>


var size = 70;
var actual = [];
var proximo = [];
var go = false;

function toggleJugadores(){
	jugadores = (jugadores+1)%3;
	iniciar();
}

function active(){
	go = !go;
	drawloop();
}

function drawloop(){
	if(go){
		nextTurn();
		setTimeout(drawloop, 100);
	}
}

iniciar();

function iniciar(){
	size = 70; //todavía falta ver cómo alterar eso.
	go = false;
	llenarCeros();
	paint();
}


var mundillo = document.getElementById("Mundo");
mundillo.addEventListener("click", set);


function llenarCeros(){
	actual = [];
	var i = 0;
	while(i < size){
		var ceros = [];
		var j = 0;
		while(j < size){
			ceros.push(0);
			j++;
		}
		actual.push(ceros);
		i++;
	}

	proximo = [];
	var h = 0;
	while(h < size){
		var ceross = [];
		var o = 0;
		while(o < size){
			ceross.push(0);
			o++;
		}
		proximo.push(ceross);
		h++;
	}
}

function vecinos(i, j){
	var acum = 0;
	if(i > 0){
		acum += actual[i-1][j];
	}
	if(i < size-1){
		acum += actual[i+1][j];
	}
	if(j > 0){
		acum += actual[i][j-1];
	}
	if(j < size-1){
		acum += actual[i][j+1];
	}
	if(i>0 && j>0){
		acum += actual[i-1][j-1];
	}
	if(i>0 && j<(size-1)){
		acum += actual[i-1][j+1];
	}
	if(i<(size-1) && j>0){
		acum += actual[i+1][j-1];
	}
	if(i<(size-1) && j<(size-1)){
		acum += actual[i+1][j+1];
	}
	return acum;
}



function paint(){
	var canvas = document.getElementById("Mundo");
	var ctx = canvas.getContext("2d");
	ctx.fillStyle = "black";
	ctx.fillRect(0, 0, 1000, 1000);
	var i = 0;
	while(i < size){
		var j = 0;
		while(j < size){
			if(actual[i][j] == 1){
				ctx.fillStyle = "#FFFFFF";
			} else {
				ctx.fillStyle = "#000000";
			}
			ctx.fillRect(i*10 + 1, j*10 + 1, 8, 8);
		j++;
		}
	i++;
	}
}


function nextTurn(){
	var i = 0;
	while(i < size){
		var j = 0;
		while(j < size){
			//document.getElementById("debugger2").innerHTML += (((actual[i][j] == 1 && vecinos(i, j) == 2 )|| vecinos(i, j) == 3) ? "true" : "false" );
			if((actual[i][j] == 1 && vecinos(i, j) == 2) || vecinos(i, j) == 3){
				proximo[i][j] = 1;
			} else {
				proximo[i][j] = 0;
			}
		j++;
		}
	i++;
	}
	copiar();
	paint();

}

function copiar(){
	var i = 0;
	while(i < size){
		var j = 0;
		while(j < size){
			var o = proximo[i][j];
			actual[i][j] = o;
		j++;
		}
	i++;
	}
}

function set(event){
	var i = event.offsetX;
	var j = event.offsetY;

	i = Math.floor(i/10);
	j = Math.floor(j/10);


	if(actual[i][j] == 1){
		actual[i][j] = 0;
	} else {
		actual[i][j] = 1;
	}
	paint();
}

function printNivel(){
	nivel = [];
	var i = 0;
	while(i < size){
		var j = 0;
		while(j < size){
			if(actual[i][j] != 0){
				nivel.push(i);
				nivel.push(j);
			}
			j++;
		}
		i++;
	}
}

var nivel = [];

function setNivel(){ // usa variable global nivel.
	iniciar();
	var i = 0;
	while(i < nivel.length){
		actual[nivel[i]][nivel[i+1]] = 1;
		i = i+2;
	}
	paint();
}

var rPentomino = [ 31, 32, 32, 31, 32, 32, 32, 33, 33, 31 ];
var blinker = [ 33, 34, 34, 34, 35, 34 ];
var beehive = [27,31,28,30,28,32,29,30,29,32,30,31];
var tableToTable = [27,28,27,31,28,28,28,29,28,30,28,31,30,28,30,29,30,30,30,31,31,28,31,31];
var triplePseudoStill = [22,34,22,36,22,38,22,39,23,32,23,33,23,34,23,36,23,37,23,39,24,31,25,32,25,34,25,35,25,37,25,38,26,31,26,32,26,34,26,35,26,37,27,38,28,30,28,32,28,33,28,35,28,36,28,37,29,30,29,31,29,33,29,35];
var quadPseudoStill = [26,34,27,33,27,35,28,33,28,35,29,29,29,30,29,32,29,33,29,35,29,36,30,29,31,30,31,32,31,33,31,35,31,36,32,29,32,30,32,32,32,33,32,35,33,36,34,28,34,30,34,31,34,33,34,34,34,35,35,28,35,29,35,31,35,33,36,32];
var pulsar = [25,27,25,28,25,29,25,33,25,34,25,35,27,25,27,30,27,32,27,37,28,25,28,30,28,32,28,37,29,25,29,30,29,32,29,37,30,27,30,28,30,29,30,33,30,34,30,35,32,27,32,28,32,29,32,33,32,34,32,35,33,25,33,30,33,32,33,37,34,25,34,30,34,32,34,37,35,25,35,30,35,32,35,37,37,27,37,28,37,29,37,33,37,34,37,35];
var glider = [33,33,34,31,34,33,35,32,35,33];
var lightweight = [32,33,32,34,32,35,33,32,33,35,34,35,35,35,36,32,36,34];
var acorn = [29,33,30,31,30,33,32,32,33,33,34,33,35,33];
var piHepto = [32,30,32,31,32,32,33,30,34,30,34,31,34,32];

function defLevel(lvl){
	iniciar();
	var i = 0;
	while (i < lvl.length){
		actual[lvl[i]][lvl[i+1]] = 1;
		i = i+2;
	}
	paint();

	mundillo.scrollIntoView();
}


</script>

<br>
<br>
<br>

<div style="text-align: justify;">

	<h2 style="color:white">
		¿Cómo funciona el juego de la vida?
	</h2>
	<p style="color:white">
		El recuardo blanco que ves arriba es el visor del juego. Tiene definida por debajo una matriz de cuadraditos que representan células. Cada una de ellas puede estar en dos estados: o bien viva o bien muerta. La aparición de cada una de estas células sigue un comportamiento definido. En cada turno, si una célula tiene exactamente tres células vecinas que están vivas, entones nace. Una célula que ya está viva, si en un paso tiene al menos dos células vecinas vivas, entonces en el paso siguiente seguirá viva. En cualquier caso contrario, una célula morirá.
	</p>
	<p style="color:white">
		Lo interesante de este juego es que, mientras que el sistema sólo tiene definido de manera muy simple el comportamiento de cada célula, sin embargo permite que emerjan fenómenos complejos y que pueden adquirir un significad determindo en un mayor nivel de abstracción. Por ejemplo, determinados conjuntos de células pueden formar una computadora programable como la que estás usando para ver esta página.
	</p>

	<br>

	<h2 style="color:white">
		Algunos patrones en el juego de la vida.
	</h2>
	<p style="color:white">
		En el juego de la vida existen varios <a href="https://www.conwaylife.com/wiki/Pattern">patrones</a>, que se organizan a su vez en varios subgrupos. Los subgrupos más difundidos son los osciladores, las vidas estáticas, las naves espaciales y los matusalenes.
	</p>
	<p style="color:white">
		Las vidas estáticas son patrones que no cambian de una generación a otra, sino que se mantienen estables. Entre las vidas estáticas se encuentran las estrictas, que son aquellas formadas por un único grupo de células, o por más de un grupo de células pero que se necestian mutuamente para sobrevivir. El <a href="javascript:;" onclick="defLevel(beehive)">panal</a> es una vida estática del primer tipo, mientras que el <a href="javascript:;" onclick="defLevel(tableToTable)">tabla sobre tabla</a> es del segundo tipo. Además, existe otro tipo de vidas estáticas (más bonitas): las vidas pseudo-estáticas. Son patrones formados por más de un grupo de células, de manera que pueden ser subdivididas. Un ejemplo es la <a href="javascript:;" onclick="defLevel(triplePseudoStill)">vida pseudo-estática triple</a> o la <a href="javascript:;" onclick="defLevel(quadPseudoStill)">cuádruple</a> (no gozaron de nombres muy creativos).
	</p>
	<p style="color:white">
		Los <a href="https://www.conwaylife.com/wiki/Oscillator">osciladores</a> son patrones que son predecesores de sí mismos. Es decir, después de una serie de pasos, el patrón vuelve a su estadío inicial, siendo la cantidad de pasos que le toma lo que se denomina su <a href="https://www.conwaylife.com/wiki/Period">ciclo</a>. Existen muchos osciladores muy recurrentes, como es el caso del <a href="javascript:;" onclick="defLevel(blinker)">"blinker"</a>. Otros son menos comunes pero son más bonitos que éste, como por ejemplo el <a href="javascript:;" onclick="defLevel(pulsar)">pulsar</a>, descubierto por Conway en 1970.
	</p>
	<p style="color:white">
		Las naves espaciales son bastante similares a los osciladores, en tanto que luego de una serie de pasos vuelve a su estado inicial. La diferencia es que al final de su período, estará en una posición diferente. Algunas de las naves espaciales más comunes son el <a href="javascript:;" onclick="defLevel(glider)">deslizador</a> (o glider) y la <a href="javascript:;" onclick="defLevel(lightweight)">nave de peso ligero</a>.
	</p>
	<p style="color:white">
		Los matusalenes (o methuselah) son patrones que se toman una gran cantidad de generaciones para estabilizarse. Es decir que estarán generando nuevos patrones durante muchos pasos del juego. Muchos methuselahs son particularmente bellos porque sus condiciones de incio son muy simples, pero pueden dar a comportamientos muy complejos y muy bellos de ver. Un ejemplo famoso es el <a href="javascript:;" onclick="defLevel(rPentomino)">R-Pentomino</a>, y otros son el <a href="javascript:;" onclick="defLevel(acorn)">acorn</a> o el <a href="javascript:;" onclick="defLevel(piHepto)">Pi-heptomino</a> (prestale atención a este último )
	</p>

	<br>

	<h2 style="color:white">
		Filosofia del Juego de la Vida.
	</h2>
	<p style="color:white">
		Una propiedad valorable de el juego de la vida es que así como se pueden representar algunas formas que se mueven de modos particulares, también <a href="https://www.ics.uci.edu/~welling/teaching/271fall09/Turing-Machine-Life.pdf">se pueden representar máquinas de Turing</a>. A partir de conjuntos de células en posiciones específicas, se puede computar en el juego de la vida cualquier algoritmo computable por una máquina de turing. En otras palabras, es <a href="https://es.wikipedia.org/wiki/Turing_completo">Turing completo</a>.
	</p>
	<p style="color:white">
		A nivel filosófico, el interés radica en los conceptos de abstracción y de fenómeno emergente. Cuando queremos describir el funcionamiento de un sistema, lo podemos hacer desde diferentes niveles de abstracción. Muchas veces, fenómenos que desde un punto de vista aparecen como muy complejos tienen un funcionamiento muy simple desde otro. Otras veces, desde un nivel de abstracción más alto podemos describir de manera simple fenómenos que desde un nivel de abstracción más bajo tendríamos que mencionar mucha más información. Las ontologías que manejamos, las formas de describir procesos y los modos de representar fenómenos pueden variar según el nivel de abstracción desde el cual se los esté mirando. Según el problema a tratar, el nivel de abstracción más útil puede variar. 
	</p>
	


</div>

</body>
</html>
